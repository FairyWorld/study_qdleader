# 粒子漂浮组件

```vue
<template>
  <canvas class="particle-canvas" ref="particleCanvas"></canvas>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, watch } from 'vue'

const props = defineProps({
  count: {
    type: Number,
    default: 50
  },
  color: {
    type: String,
    default: 'rgba(56, 162, 238, 0.6)'
  },
  size: {
    type: Object,
    default: () => ({
      min: 1,
      max: 4
    })
  },
  speed: {
    type: Object,
    default: () => ({
      min: 0.1,
      max: 0.5
    })
  },
  connectionDistance: {
    type: Number,
    default: 100
  },
  connectionOpacity: {
    type: Number,
    default: 0.3
  }
})

const particleCanvas = ref(null)
let particles = []
let animationFrameId = null
let ctx = null
let canvasWidth = 0
let canvasHeight = 0

function createParticle() {
  return {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: props.size.min + Math.random() * (props.size.max - props.size.min),
    speedX: (Math.random() - 0.5) * (props.speed.max - props.speed.min) + props.speed.min,
    speedY: (Math.random() - 0.5) * (props.speed.max - props.speed.min) + props.speed.min,
    opacity: Math.random() * 0.8 + 0.2
  }
}

function initCanvas() {
  const canvas = particleCanvas.value
  if (!canvas) return

  ctx = canvas.getContext('2d')

  // Set canvas dimensions to match parent container
  resizeCanvas()

  // Create particles
  particles = []
  for (let i = 0; i < props.count; i++) {
    particles.push(createParticle())
  }
}

function resizeCanvas() {
  const canvas = particleCanvas.value
  if (!canvas) return

  const parent = canvas.parentElement
  canvasWidth = parent.offsetWidth
  canvasHeight = parent.offsetHeight

  // Set canvas size to match parent with device pixel ratio for sharp rendering
  const dpr = window.devicePixelRatio || 1
  canvas.width = canvasWidth * dpr
  canvas.height = canvasHeight * dpr
  canvas.style.width = `${canvasWidth}px`
  canvas.style.height = `${canvasHeight}px`

  // Scale context to match device pixel ratio
  ctx.scale(dpr, dpr)
}

function drawParticles() {
  if (!ctx) return

  // Clear canvas
  ctx.clearRect(0, 0, canvasWidth, canvasHeight)

  // Draw connections first (so they appear behind particles)
  for (let i = 0; i < particles.length; i++) {
    const particle1 = particles[i]

    for (let j = i + 1; j < particles.length; j++) {
      const particle2 = particles[j]

      // Calculate distance between particles
      const dx = particle1.x - particle2.x
      const dy = particle1.y - particle2.y
      const distance = Math.sqrt(dx * dx + dy * dy)

      // Draw connection line if particles are close enough
      if (distance < props.connectionDistance) {
        // Calculate opacity based on distance (closer = more opaque)
        const opacity = (1 - distance / props.connectionDistance) * props.connectionOpacity

        ctx.beginPath()
        ctx.moveTo(particle1.x, particle1.y)
        ctx.lineTo(particle2.x, particle2.y)
        ctx.strokeStyle = props.color.replace(/[^,]+(?=\))/, opacity)
        ctx.lineWidth = 0.5
        ctx.stroke()
      }
    }
  }

  // Draw particles
  particles.forEach(particle => {
    ctx.beginPath()
    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2)
    ctx.fillStyle = props.color.replace(/[^,]+(?=\))/, particle.opacity)
    ctx.fill()
  })
}

function updateParticles() {
  particles.forEach(particle => {
    // Update position
    particle.x += particle.speedX
    particle.y += particle.speedY

    // Bounce off edges
    if (particle.x <= 0 || particle.x >= canvasWidth) {
      particle.speedX = -particle.speedX
    }

    if (particle.y <= 0 || particle.y >= canvasHeight) {
      particle.speedY = -particle.speedY
    }
  })
}

function animate() {
  updateParticles()
  drawParticles()
  animationFrameId = requestAnimationFrame(animate)
}

function cleanup() {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId)
  }

  window.removeEventListener('resize', resizeCanvas)
  particles = []
}

onMounted(() => {
  initCanvas()
  animate()
  window.addEventListener('resize', () => {
    resizeCanvas()
    // Redistribute particles when canvas is resized
    particles.forEach(particle => {
      if (particle.x > canvasWidth) particle.x = Math.random() * canvasWidth
      if (particle.y > canvasHeight) particle.y = Math.random() * canvasHeight
    })
  })
})

onBeforeUnmount(() => {
  cleanup()
})

// Watch for prop changes to update particles
watch(() => props.count, (newCount, oldCount) => {
  const diff = newCount - oldCount

  if (diff > 0) {
    // Add new particles
    for (let i = 0; i < diff; i++) {
      particles.push(createParticle())
    }
  } else if (diff < 0) {
    // Remove particles
    particles = particles.slice(0, newCount)
  }
}, { deep: true })
</script>

<style scoped>
.particle-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}
</style>

```


使用方法：

1. 将上述代码保存为一个名为 `ParticleCanvas.vue` 的文件。
2. 在需要使用粒子漂浮效果的组件中，引入并注册 `ParticleCanvas` 组件。
3. 在模板中使用 `ParticleCanvas` 组件，并设置相应的属性。

例如：

```vue
<template>
  <div class="container">
    <ParticleCanvas :count="100" :speed="speed" :connectionDistance="100" :connectionOpacity="0.2" />
    <!-- 其他内容 -->
  </div>
</template>

<script>
import ParticleCanvas from './ParticleCanvas.vue'

```