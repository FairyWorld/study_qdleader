## 变量输出


```js
var foo = {n: 1};
var bar = foo;
foo.x = foo = {n: 2};
console.log(foo.x)
console.log(bar.x)


















// undefined
// {n: 2}
```



## 解析

```js
var foo = {n: 1};

    创建了一个对象字面量 {n: 1}
    将这个对象的引用赋值给变量 foo
    此时 foo 指向内存中地址为 {n: 1} 的对象
    var bar = foo;

    将 foo 的引用复制给 bar
    现在 foo 和 bar 都指向同一个对象 {n: 1}
    修改 foo 或 bar 都会影响同一个对象




foo.x = foo = {n: 2};
    这是最复杂的一行，需要分解来看：

        a) 首先，赋值操作是从右到左进行的，但属性赋值是同时发生的
        b) foo = {n: 2} 会将 foo 的引用改为指向新对象 {n: 2}
        c) 但在此之前，foo.x = ... 会先执行，在旧对象上添加 x 属性
        d) 所以实际上是：先在旧对象 {n: 1} 上添加 x 属性，值为 {n: 2}，然后将 foo 指向新对象

执行后：

foo 指向 {n: 2}
bar 仍然指向旧对象，但旧对象现在变成了 {n: 1, x: {n: 2}}
console.log(foo.x)

    输出 foo.x 的值
    由于 foo 现在指向 {n: 2}，而这个对象没有 x 属性
    所以结果是 undefined


最终输出会是：undefined

```